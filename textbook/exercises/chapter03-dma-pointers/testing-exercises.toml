[[exercises]]
question-id = "chapter-03-Q1"
title = "Question 3 in Fall 2022 Midterm Exam"
difficulty = "Easy"
table = false
type = "explaination"
multipart= false

question = '''

Consider the following C++ function:

```{code-block} cpp
void AvadaKedavra(int n) {
  int size = n + 1;
  int* q = NULL;
  for (int i = 0; i < 3; ++i) {
    q = new int[size];
  }
}
```

If somewhere in your main function you call `AvadaKedavra(1)`. Based on the memory layout discussed during the lecture, answer this question: from the time this function starts to execute to the time right before it returns, how many bytes are newly allocated on the stack and the heap, respectively?

You may assume:
1. all variables are put in the main memory.
2. an `int` takes 4 bytes
3. we have a 32-bit machine

'''

answer = '''

**Stack**

`n`: 4 bytes

`size`: 4 bytes

`q`: 4 bytes

`i`: 4 bytes

Total: 16 bytes

----------------
**Heap**

`n` is 1, `size` is 2

The loop iterates 3 times, each time it allocates 2 integers. 

Total is 3 * 2 * 4 bytes = 24 bytes.
'''


[[exercises]]
question-id = "chapter-03-Q2"
title = "Question 9 in Fall 2021 Midterm Exam"
difficulty = "Intermediate"
type = "explaination"
table = true

question = '''
Consider the code shown below. You can assume it compiles with no errors and runs. 

```{code-block} cpp
#include <iostream>
using namespace std;

int a = 0;
int* b = &a;
int** c = &b;

int* foo(int** d) {
  (**d)++;
  b = *d;
  int* e = new int;
  *e = 10;
  return e;
}

int main() {
  int* g = nullptr;
  int* f = new int;
  *f = 5;
  a++;

  // Point 1

  g = foo(&f);
  a++;
  (*g)++;

  // Point 2

  return 0;
}

```

In the table below, give the values of the variables indicated in the table columns when program execution reaches each of the two points, Point 1 and Point 2. If a value cannot be obtained due to dereferencing a `nullptr` pointer, write `nullptr` (but assume the program does not stop).

'''

headers = ["Point", "a", "*b", "**c", "*g", "*f"]  
rows = [
  ["Point 1", "", "", "", "", ""],
  ["Point 2", "", "", "", "", ""],
]

answer = [
  ["Point 1", "1", "1", "1", "nullptr", "5"],
  ["Point 2", "2", "6", "6", "11", "6"],
]






[[exercises]]
question-id = "chapter-03-Q3"
title = "Question 10 in Fall 2022 Midterm Exam"
difficulty = "Challenging"
type = "function programming"
table = false
multipart = true

question = '''

A Vtuber is an online entertainer who posts videos on Vtube. A Vtuber will have followers on Vtube. As a programmer from Vtube, you are asked to implement a class for Vtuber. The class definition and description are described below.

```{code-block} cpp
#include <iostream>
#include <string>
using namespace std;

class Follower {
 private:
  string name;
  int age;

 public:
  Follower(const string& _name, int _age) {
    name = _name;
    age = _age;
  }
  string get_name() const { return name; }
  int get_age() const { return age; }
};
class Vtuber {
 private:
  // Vtuber Name
  string name;
  // Follower array with a variable size, each element should be a dynamically
  // allocated object of class Follower.
  Follower** followers;
  // The size of follower array.
  int follower_max;
  // Number of followers
  int follower_num;

 public:
  Vtuber(const string& _name);
  ~Vtuber();
  void insert_follower(const string& follower_name, int follower_age);
  void remove_follower(const string& follower_name);
};

```

Specifically, Vtuber's followers member variable is an array of pointers, each pointer pointing to a `Follower` object. The following graph illustrates it.

```{figure} _images/followers.png
```

(1) Implement the constructor for `Vtuber`. Vtuber `name` should be initialized by `_name`, and `follower_max` should be initialized to 2. In addition, you should allocate an array called `followers` using `new`, with an initial size of 2 (the value of `follower_max`). Every element in this array should be a pointer to an object of class `Follower` and initialize all these pointers to `NULL`.
'''

starter-code = '''

Vtuber::Vtuber (const string& _name) {
  
  // Your code here

}

'''

answer = '''

Vtuber::Vtuber(const string& _name) {
  name = _name;
  follower_max = 2;
  follower_num = 0;
  followers = new Follower*[follower_max];
  for (int i = 0; i < follower_max; i++) {
    followers[i] = NULL;
  }
}

'''

append-before = '''
#include <iostream>
#include <string>
using namespace std;

class Follower {
 private:
  string name;
  int age;

 public:
  Follower(const string& _name, int _age) {
    name = _name;
    age = _age;
  }
  string get_name() const { return name; }
  int get_age() const { return age; }
  
};
class Vtuber {
 private:
  string name;
  Follower** followers;
  int follower_max;
  int follower_num;

 public:
  Vtuber(const string& _name);

  // getters for testing
  string get_name() const { return name; }
  int get_follower_max() const { return follower_max; }
  int get_follower_num() const { return follower_num; }
  bool followers_all_null() const {
    for (int i = 0; i < follower_max; i++) {
      if (followers[i] != NULL) return false;
    }
    return true;
  }

};
'''

main-function = '''
int main() {
  string vtuber_name;
  getline(cin, vtuber_name);

  Vtuber v(vtuber_name);

  cout << "Vtuber created: " << v.get_name() << endl;
  cout << "Max followers allowed: " << v.get_follower_max() << endl;
  cout << "Current number of followers: " << v.get_follower_num() << endl;
  cout << "All followers initialized to NULL: "
       << (v.followers_all_null() ? "Yes" : "No") << endl;

  return 0;
}
'''

[[exercises.testcases]]
input = "Q3.P1.T1.in"
output = "Q3.P1.T1.out"

[[exercises.testcases]]
input = "Q3.P1.T2.in"
output = "Q3.P1.T2.out"

[[exercises.testcases]]
input = "Q3.P1.T3.in"
output = "Q3.P1.T3.out"




[[exercises]]
question-id = "chapter-03-Q4"
title = "Question 10 in Fall 2022 Midterm Exam"
difficulty = "Challenging"
type = "function programming"
table = false
multipart = true

question = '''

(2) Every Vtuber in `Vtube` can get new followers or lose their current followers. This is implemented by two methods: `insert_follower` and `remove_follower`. Now you are asked to implement these two methods:

a. For insert_follower, a follower name and follower age are given. You need to create a dynamically allocated object of `Follower` and insert it into the followers array (in the first available location), using `new` operator. If the array is full, you should double `follower_max`, allocate a new follower array, and move all the data into this `new` array, and insert the `new` follower. Write the code below.
'''

starter-code = '''
void Vtuber::insert_follower(const string& follower_name, 
                            int follower_age) {

  // Your code here

}
'''

answer = '''
void Vtuber::insert_follower(const string& follower_name, int follower_age) {
  follower_num++;
  for (int i = 0; i < follower_max; i++) {
    if (followers[i] == NULL) {
      followers[i] = new Follower(follower_name, follower_age);
      return;
    }
  }
  Follower** new_followers = new Follower*[2 * follower_max];
  for (int i = 0; i < follower_max; i++) {
    new_followers[i] = followers[i];
    new_followers[i + follower_max] = NULL;
  }
  new_followers[follower_max] = new Follower(follower_name, follower_age);
  delete[] followers;
  followers = new_followers;
  follower_max *= 2;
  return;
}
'''

append-before = '''
#include <iostream>
#include <string>
using namespace std;

class Follower {
 private:
  string name;
  int age;

 public:
  Follower(const string& _name, int _age) {
    name = _name;
    age = _age;
  }
  string get_name() const { return name; }
  int get_age() const { return age; }
};

class Vtuber {
 private:
  string name;
  Follower** followers;
  int follower_max;
  int follower_num;

 public:
  Vtuber(const string& _name);
  void insert_follower(const string& follower_name, int follower_age);

  // Extra helper for testcases
  void print_followers() const {
    cout << "Vtuber: " << name << " has " << follower_num << " followers:" << endl;
    for (int i = 0; i < follower_max; i++) {
      if (followers[i] != NULL) {
        cout << "- " << followers[i]->get_name()
             << " (age " << followers[i]->get_age() << ")" << endl;
      }
    }
  }
};

// Constructor from part (1)
Vtuber::Vtuber(const string& _name) {
  name = _name;
  follower_max = 2;
  follower_num = 0;
  followers = new Follower*[follower_max];
  for (int i = 0; i < follower_max; i++) {
    followers[i] = NULL;
  }
}
  
'''

main-function = '''

int main() {
  string vtuber_name;
  getline(cin, vtuber_name);  // full Vtuber name
  Vtuber v(vtuber_name);

  string command;
  while (cin >> command) {
    if (command == "Insert") {
      int n;
      cin >> n;
      for (int i = 0; i < n; i++) {
        string name;
        int age;
        cin >> name >> age;
        v.insert_follower(name, age);
      }
    } else {
      cerr << "Unknown command: " << command << endl;
      break;
    }
  }

  v.print_followers();
  return 0;
}

'''


[[exercises.testcases]]
input = "Q3.P2a.T1.in"
output = "Q3.P2a.T1.out"

[[exercises.testcases]]
input = "Q3.P2a.T2.in"
output = "Q3.P2a.T2.out"

[[exercises.testcases]]
input = "Q3.P2a.T3.in"
output = "Q3.P2a.T3.out"


[[exercises]]
question-id = "chapter-03-Q5"
title = "Question 10 in Fall 2022 Midterm Exam"
difficulty = "Challenging"
type = "function programming"
table = false
multipart = true

question = '''
b. For `remove_follower`, a follower name is given. If there is any follower in the array matching the name, you should remove it and free its memory using `delete`. You can assume the follower names are all unique.
'''

starter-code = '''
void Vtuber::remove_follower(const string& follower_name) {
  
  // Your code here

}
'''

answer = '''
void Vtuber::remove_follower(const string& follower_name) {
  for (int i = 0; i < follower_max; i++) {
    if (followers[i] == NULL)  // 3 marks on skipping NULL members
      continue;
    if (followers[i]->get_name() == follower_name) {  // 1 mark
      follower_num--;                                 // 1 mark
      delete followers[i];                            // 2 mark
      followers[i] = NULL;                            // 1 mark
      break;
    }
  }
  return;
}
'''

append-before = '''
#include <iostream>
#include <string>
using namespace std;

class Follower {
 private:
  string name;
  int age;

 public:
  Follower(const string& _name, int _age) {
    name = _name;
    age = _age;
  }
  string get_name() const { return name; }
  int get_age() const { return age; }
};

class Vtuber {
 private:
  string name;
  Follower** followers;
  int follower_max;
  int follower_num;

 public:
  Vtuber(const string& _name);
  void insert_follower(const string& follower_name, int follower_age);
  void remove_follower(const string& follower_name);

  // Extra helper for testcases
  void print_followers() const {
    cout << "Vtuber: " << name << " has " << follower_num << " followers:" << endl;
    for (int i = 0; i < follower_max; i++) {
      if (followers[i] != NULL) {
        cout << "- " << followers[i]->get_name()
             << " (age " << followers[i]->get_age() << ")" << endl;
      }
    }
  }
};

// Constructor from part (1)
Vtuber::Vtuber(const string& _name) {
  name = _name;
  follower_max = 2;
  follower_num = 0;
  followers = new Follower*[follower_max];
  for (int i = 0; i < follower_max; i++) {
    followers[i] = NULL;
  }
}

// insert_follower from part (2a)
void Vtuber::insert_follower(const string& follower_name, int follower_age) {
  follower_num++;
  for (int i = 0; i < follower_max; i++) {
    if (followers[i] == NULL) {
      followers[i] = new Follower(follower_name, follower_age);
      return;
    }
  }
  Follower** new_followers = new Follower*[2 * follower_max];
  for (int i = 0; i < follower_max; i++) {
    new_followers[i] = followers[i];
    new_followers[i + follower_max] = NULL;
  }
  new_followers[follower_max] = new Follower(follower_name, follower_age);
  delete[] followers;
  followers = new_followers;
  follower_max *= 2;
  return;
}
'''


main-function = '''
int main() {
  string vtuber_name;
  getline(cin, vtuber_name);
  Vtuber v(vtuber_name);

  string command;
  while (cin >> command) {
    if (command == "Insert") {
      int n;
      cin >> n;
      for (int i = 0; i < n; i++) {
        string name;
        int age;
        cin >> name >> age;
        cout << "Inserting follower: " << name << " (age " << age << ")" << endl;
        v.insert_follower(name, age);
      }
    } else if (command == "Remove") {
      int n;
      cin >> n;
      for (int i = 0; i < n; i++) {
        string name;
        cin >> name;
        cout << "Removing follower: " << name << endl;
        v.remove_follower(name);
      }
    } else {
      cout << "Unknown command: " << command << endl;
    }
  }

  v.print_followers();
  return 0;
}
'''

[[exercises.testcases]]
input = "Q3.P2b.T1.in"
output = "Q3.P2b.T1.out"

[[exercises.testcases]]
input = "Q3.P2b.T2.in"
output = "Q3.P2b.T2.out"

[[exercises.testcases]]
input = "Q3.P2b.T3.in"
output = "Q3.P2b.T3.out"

[[exercises]]
question-id = "chapter-03-Q6"
title = "Question 10 in Fall 2022 Midterm Exam"
difficulty = "Challenging"
type = "explaination"
table = false
multipart = true

question = '''

(3) Implement the destructor for the `Vtuber` class. You should free all the dynamically allocated objects using `delete`. Remember to be consistent with your previous implementation, as the entire program should not trigger any segmentation fault.

'''
answer = """
<code>
Vtuber::~Vtuber() {

for (int i = 0; i < follower_max; i++) {

delete followers[i];  // delete NULL is safe;

}

delete[] followers;

}
</code>
"""


[[exercises]]
question-id = "chapter-03-Q7"
title = "Question 2 in Fall 2019 Midterm Exam"
difficulty = "Intermediate"
table = false
type = "explaination"
multipart= false

question = '''

Consider the definition of a class called `Nova`, which is in the file `Nova.h`.

```{code-block} cpp
#include <iostream>
using namespace std;
class Nova {
 private:
 // Private members not shown
 public:
 // Public members not shown
};
```

Now consider the following program that uses the `Nova` class. The program compiles and runs correctly.

```{code-block} cpp
#include <iostream>
using namespace std;
#include “Nova.h”
int main() {
  Nova a(3, 8.1);
  Nova* p;
  Nova b(a);
  ++a.it;
  a.setAll(1, 7.8);
  p = new Nova(9, 12.7);
  if (a != b)
    *p = a + b;
  delete p;
  return 0;
}
```
What members of the class Nova must exist for the above code to compile with no errors? Give variable declarations and/or method prototypes in the table below. Note that you may or may not need to fill every row in the table. 

'''

answer = '''
Nova(int, double);

int it;

void setAll(int,double);

Nova operator+(Nova&)

bool operator!=(Nova&)

No need for destructor as we don't dynamically allocate space in the object.

No need for a copy constructor in `Nova b(a)` since one is given by default.

No need for `operator=` in `*p = a + b`
'''


[[exercises]]
question-id = "chapter-03-Q8"
title = "Question 7 in Fall 2018 Midterm Exam"
difficulty = "Intermediate"
type = "function programming"
table = false

question = '''
The following is the definition/implementation of a class called `Foo`.

```{code-block} cpp
class Foo {
 private:
  int priv;

 public:
  Foo(int pv) { priv = pv; }
  Foo(const Foo src) { priv = src.priv; }
  Foo& operator=(Foo& rhs) const {
    priv = rhs.priv;
    return this;
  }
  int getPriv() const { return priv; }
  void setPriv(int pv) { priv = pv; }
};
```

Compiling the above definition/implementation results in one or more errors.
Re-write the class so it is error-free. 

'''

starter-code = '''

class Foo {
 private:
  int priv;

 public:
  Foo(int pv) { priv = pv; }
  Foo(const Foo src) { priv = src.priv; }
  Foo& operator=(Foo& rhs) const {
    priv = rhs.priv;
    return this;
  }
  int getPriv() const { return priv; }
  void setPriv(int pv) { priv = pv; }
};

'''

answer = '''

1. The copy constructor should take its argument as a const reference. Otherwise, 
it will call itself infinitely. Line 7 changed to add `&` after `const Foo`. 

2. The assignment operator (operator=) should not be declared `const` as we want 
to change `priv` in line 8.

3. The assignment operator (operator=) returns `Foo&`, while `this` is `Foo*` type. 
Change `this` to `*this` in line 10.

class Foo {
 private:
  int priv;

 public:
  Foo(int pv) { priv = pv; }
  Foo(const Foo& src) { priv = src.priv; }
  Foo& operator=(const Foo& rhs) {
    priv = rhs.priv;
    return *this;
  }
  int getPriv() const { return priv; }
  void setPriv(int pv) { priv = pv; }
};
'''

main-function = '''
#include <iostream>
using namespace std;

int main() {
  int aval, bval, newval;
  cin >> aval >> bval >> newval;

  Foo a(aval);
  Foo b(bval);

  cout << "Testing copy constructor:" << endl;
  Foo c = a; 
  cout << "c copies a = " << c.getPriv() << endl;

  cout << "Testing assignment operator:" << endl;
  c = b;
  cout << "c after assignment from b = " << c.getPriv() << endl;

  cout << "Testing setter/getter:" << endl;
  c.setPriv(newval);
  cout << "c after setPriv = " << c.getPriv() << endl;
  cout << "a remains = " << a.getPriv() << endl;

  cout << "Testing self-assignment:" << endl;
  c = c;
  cout << "c after self-assign = " << c.getPriv() << endl;

  return 0;
}
'''

[[exercises.testcases]]
input = "Q5.T1.in"
output = "Q5.T1.out"

[[exercises.testcases]]
input = "Q5.T2.in"
output = "Q5.T2.out"

[[exercises.testcases]]
input = "Q5.T3.in"
output = "Q5.T3.out"


[[exercises]]
question-id = "chapter-03-Q9"
title = "Modified Version of Question 9 in Fall 2018 Midterm Exam"
difficulty = "Intermediate"
table = false
type = "tracing"
multipart= false

question = '''

Consider the following definition/implementation of a class called `Shape` that appears in the file: `Shape.h`.

**Shape.h**
```{code-block} cpp
#include <iostream>
using namespace std;
class Shape {
 private:
  int ID;

 public:
  Shape() {
    ID = 0;
    cout << "Constructor 1 " << ID << endl;
  }
  Shape(int id) {
    ID = id;
    cout << "Constructor 2 " << ID << endl;
  }
  Shape(const Shape& s) {
    ID = s.ID;
    cout << "Constructor 3 " << ID << endl;
  }
  ~Shape() { cout << "Destructor " << endl; }
  Shape& operator=(Shape rhs) {
    cout << "Operator= " << ID << endl;
    ID = rhs.ID;
    return *this;
  }
  int getID() const { return ID; }
  void setID(int id) { ID = id; }
};
```

The following is a main program that uses the above class.

**main.cpp**
```{code-block} cpp
#include <iostream>
using namespace std;
#include "Shape.h"
int getID(Shape s) {
  return s.getID();
}
int getShapeID(Shape& s) {
  return s.getID();
}
int main() {
  Shape circle(5);
  Shape* line1[2];
  Shape* polygon = new Shape(circle);
  line1[0] = polygon;
  line1[1] = polygon;
  *polygon = circle;
  Shape line2[2];
  line2[0] = *polygon;
  cout << (*(line1[0])).getID() << endl;
  cout << getID(*line1[1]) << endl;
  cout << getShapeID(*line1[0]) << endl;
  return 0;
}
```

What is the output of the program? 

'''
answer = '''
Constructor 2 5
Constructor 3 5
Constructor 3 5
Operator= 5
Destructor 
Constructor 1 0
Constructor 1 0
Constructor 3 5
Operator= 0
Destructor 
5
Constructor 3 5
Destructor 
5
5
Destructor 
Destructor 
Destructor 
'''


[[exercises]]
question-id = "chapter-03-Q10"
title = "Question 8 in Fall 2021 Midterm Exam"
difficulty = "Intermediate"
table = false
type = "explaination"
multipart= false

question = '''
Consider the definition of a class called `Mystery`, which is in the file `Mystery.h`.  

**Mystery.h**

```{code-block} cpp
#include <iostream>
using namespace std;

class Mystery {
 private:
  // Private members not shown

 public:
  // Public members not shown
};
```

Now consider the following program that uses the `Mystery` class. The program compiles and runs correctly.

**main.cpp**
```{code-block} cpp
#include <iostream>
#include <string>
using namespace std;

#include "Mystery.h"

int main() {
  string n = "hello";
  Mystery x(3, n);
  Mystery* p = new Mystery(n, 4);
  Mystery y(x);
  x.invert(1, n);
  if (x == y)
    x = y / *p;
  delete p;

  return 0;
}
```

What public members of the class Mystery **must exist** (either written by the programmer or given by C++) for the above code to compile with no errors? Non-member functions are not allowed. Write necessary variable declarations and/or method prototypes.
'''

answer = '''
`Mystery(const Mystery&);` // used here: Mystery y(x);

`Mystery(string, int);` // used here: Mystery(n, 4)

`Mystery(int, string);` // used here: Mystery x(3, n);

`void invert(int, string);` // used here: x.invert(1, n)

`bool operator==(const Mystery& right);` // used here: x == y

`Mystery operator/(const Mystery& right);` // used here: y / *p;

`Mystery& operator=(const Mystery&);` // used here: x = y;

`~Mystery();` // used here: delete p;
'''


[[exercises]]
question-id = "chapter-03-Q11"
title = "Question 8 in Fall 2022 Midterm Exam"
difficulty = "Challenging"
table = false
type = "function programming"
multipart= false

question = '''
Vector is widely used in the engineering and science world. Suppose we create a class called `vector_2d`. It can be used to represent a 2D 
vector, with `x` and `y` as its values. The partial code of this vector is given below.

Implement `operator+=` for `vector_2d`, as a member function. 

If `a = <x1, y1>` and `b = <x2, y2>`, after `a += b`, `a` becomes `<x1 + x2, y1 + y2>` whereas `b` is unchanged. Write no more than 5 lines of code.

'''

starter-code = '''
class vector_2d {
 private:
  double x;
  double y;

 public:
  vector_2d() {
    x = 0;
    y = 0;
  }
  vector_2d(double x_, double y_) {
    x = x_;
    y = y_;
  }
  double get_x() const { return x; }
  double get_y() const { return y; }
  
  // TO DO: Implement overloaded operator+= here


};
'''

answer = '''

vector_2d& operator+=(const vector_2d& rhs) {
  // need to do the changes on the members of the lhs object
  x += rhs.x;
  y += rhs.y;
  // need to return the lhs object.
  // Return by reference is to make sure we don't return a copy
  return *this;
}

NOTE: the return type cannot be `void`, because we need to support chained `+=`.
Example: `a += b += 2;`
which is equivalent to:
`b += 2;`
`a += b;`

'''

main-function = '''
#include <iostream>
using namespace std;

int main() {
  double ax, ay, bx, by, cx, cy;
  cin >> ax >> ay >> bx >> by >> cx >> cy;

  vector_2d a(ax, ay);
  vector_2d b(bx, by);
  vector_2d c(cx, cy);

  cout << "Initial vectors:" << endl;
  cout << "a = <" << a.get_x() << ", " << a.get_y() << ">" << endl;
  cout << "b = <" << b.get_x() << ", " << b.get_y() << ">" << endl;
  cout << "c = <" << c.get_x() << ", " << c.get_y() << ">" << endl;

  cout << "\nTesting a += b:" << endl;
  a += b;
  cout << "a = <" << a.get_x() << ", " << a.get_y() << ">" << endl;
  cout << "b = <" << b.get_x() << ", " << b.get_y() << ">" << endl;

  cout << "\nTesting chained (a += b) += c:" << endl;
  (a += b) += c;
  cout << "a = <" << a.get_x() << ", " << a.get_y() << ">" << endl;

  return 0;
}
'''

[[exercises.testcases]]
input = "Q8.T1.in"
output = "Q8.T1.out"

[[exercises.testcases]]
input = "Q8.T2.in"
output = "Q8.T2.out"

[[exercises.testcases]]
input = "Q8.T3.in"
output = "Q8.T3.out"


[[exercises]]
question-id = "chapter-03-Q12"
title = "Modified Version of Question 14 in Fall 2019 Midterm Exam"
difficulty = "Intermediate"
table = false
type = "function programming"
multipart= true

question = '''

The following class is used to create objects that represent ordinary fractions `n/d`, consisting of a numerator `n` and a denominator `d`.

```{code-block} cpp
#include <iostream>
using namespace std;
class Fraction {
 private:
  int numerator;
  int denominator;

 public:
  Fraction(int num, int denm);
  int getNumerator();
  int getDenominator();
  void setNumerator(int num);
  void setDenominator(int denm);
  void print();
};

Fraction::Fraction(int num, int denm) {
  numerator = num;
  // Should check that denm is not 0, but ignore for now
  denominator = denm;
}
int Fraction::getNumerator() {
  return (numerator);
}
int Fraction::getDenominator() {
  return (denominator);
}
void Fraction::setNumerator(int num) {
  numerator = num;
}
void Fraction::setDenominator(int denm) {
  // Should check that denm is not 0, but ignore for now
  denominator = denm;
}
void Fraction::print() {
  cout << numerator << "/" << denominator << endl;
}
```

We wish to overload the `*` operator for the Fraction class to be able to write code like this in a non-member function (say main):

```{code-block} cpp
Fraction X(1, 5);
Fraction Y(4, 6);
 :
 .. = X * Y; // The first multiply operation
 ..= X * 2;  // The second multiply operation
```

For example, if `X` represents `1/5` and `Y` represents `4/6` then `X * Y` results in an object that represents `4/30`, while `X * 2` results in an object that represents `2/10`. That is, both the numerator and denominator are multiplied by `2`.

Write the implementation of the two overloaded operator functions as members of the class
Fraction. Clearly show the function header and its body.

1. Overload the multiplication operator `*` as a member of the class `Fraction` to be
able to perform the first multiply operation (see comments below). Be sure to indicate both the header and the body of the method. You need not worry about using const modifiers.

2. Overload the multiplication operator `*` as a member of the class `Fraction` to be
able to perform the second multiply operation (see comments below). Be sure to indicate both the header and the body of the method. You need not worry about using const modifiers.

'''

starter-code = '''

#include <iostream>
using namespace std;
class Fraction {
 private:
  int numerator;
  int denominator;

 public:
  Fraction(int num, int denm);
  int getNumerator();
  int getDenominator();
  void setNumerator(int num);
  void setDenominator(int denm);
  void print();

  // TODO: Declare operator* overloads here

};

Fraction::Fraction(int num, int denm) {
  numerator = num;
  denominator = denm;
}
int Fraction::getNumerator() {
  return (numerator);
}
int Fraction::getDenominator() {
  return (denominator);
}
void Fraction::setNumerator(int num) {
  numerator = num;
}
void Fraction::setDenominator(int denm) {
  denominator = denm;
}
void Fraction::print() {
  cout << numerator << "/" << denominator << endl;
}

// TODO: Implement operator overloads below


'''

answer = '''

// TODO: Declare operator* overloads here

Fraction operator*(Fraction& rhs);
Fraction operator*(int x);

// TODO: Implement operator overloads below

Fraction Fraction::operator*(Fraction& rhs) {
  Fraction w(numerator * rhs.numerator, denominator * rhs.denominator);
  return w;
}

Fraction Fraction::operator*(int x) {
  Fraction w(numerator * x, denominator * x);
  return w;
}

'''

main-function = '''

#include <iostream>
using namespace std;

int main() {
    int n1, d1, n2, d2, k;
    cin >> n1 >> d1 >> n2 >> d2 >> k;

    Fraction X(n1, d1);
    Fraction Y(n2, d2);

    cout << "Initial fractions:" << endl;
    cout << "X = ";
    X.print();
    cout << "Y = ";
    Y.print();
    cout << "Integer k = " << k << endl;

    cout << "\nTesting Fraction * Fraction:" << endl;
    Fraction Z = X * Y;
    cout << "Z = X * Y = ";
    Z.print();

    cout << "\nTesting Fraction * int:" << endl;
    Fraction W = X * k;
    cout << "W = X * k = ";
    W.print();

    return 0;
}
'''

[[exercises.testcases]]
input = "Q9.T1.in"
output = "Q9.T1.out"

[[exercises.testcases]]
input = "Q9.T2.in"
output = "Q9.T2.out"

[[exercises.testcases]]
input = "Q9.T3.in"
output = "Q9.T3.out"

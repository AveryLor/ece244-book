[[exercises]]
title = "Question 3 in Fall 2022 Midterm Exam"
difficulty = "Easy"
table = false
type = "explaination"
multipart= false

question = '''

Consider the following C++ function:

```{code-block} cpp
void AvadaKedavra(int n) {
  int size = n + 1;
  int* q = NULL;
  for (int i = 0; i < 3; ++i) {
    q = new int[size];
  }
}
```

If somewhere in your main function you call `AvadaKedavra(1)`. Based on the memory layout discussed during the lecture, answer this question: from the time this function starts to execute to the time right before it returns, how many bytes are newly allocated on the stack and the heap, respectively?

You may assume:
1. all variables are put in the main memory.
2. an `int` takes 4 bytes
3. we have a 32-bit machine

'''

answer = '''

**Stack**

`n`: 4 bytes

`size`: 4 bytes

`q`: 4 bytes

`i`: 4 bytes

Total: 16 bytes

----------------
**Heap**

`n` is 1, `size` is 2

The loop iterates 3 times, each time it allocates 2 integers. 

Total is 3 * 2 * 4 bytes = 24 bytes.
'''


[[exercises]]
title = "Question 9 in Fall 2021 Midterm Exam"
difficulty = "Intermediate"
type = "explaination"
table = true

question = '''
Consider the code shown below. You can assume it compiles with no errors and runs. 

```{code-block} cpp
#include <iostream>
using namespace std;

int a = 0;
int* b = &a;
int** c = &b;

int* foo(int** d) {
  (**d)++;
  b = *d;
  int* e = new int;
  *e = 10;
  return e;
}

int main() {
  int* g = nullptr;
  int* f = new int;
  *f = 5;
  a++;

  // Point 1

  g = foo(&f);
  a++;
  (*g)++;

  // Point 2

  return 0;
}

```

In the table below, give the values of the variables indicated in the table columns when program execution reaches each of the two points, Point 1 and Point 2. If a value cannot be obtained due to dereferencing a `nullptr` pointer, write `nullptr` (but assume the program does not stop).

'''

headers = ["Point", "a", "*b", "**c", "*g", "*f"]  
rows = [
  ["Point 1", "", "", "", "", ""],
  ["Point 2", "", "", "", "", ""],
]

answer = [
  ["Point 1", "1", "1", "1", "nullptr", "5"],
  ["Point 2", "2", "6", "6", "11", "6"],
]






[[exercises]]
title = "Question 10 in Fall 2022 Midterm Exam"
difficulty = "Challenging"
type = "function programming"
table = false
multipart = true

question = '''

A Vtuber is an online entertainer who posts videos on Vtube. A Vtuber will have followers on Vtube. As a programmer from Vtube, you are asked to implement a class for Vtuber. The class definition and description are described below.

```{code-block} cpp
#include <iostream>
#include <string>
using namespace std;

class Follower {
 private:
  string name;
  int age;

 public:
  Follower(const string& _name, int _age) {
    name = _name;
    age = _age;
  }
  string get_name() const { return name; }
  int get_age() const { return age; }
};
class Vtuber {
 private:
  // Vtuber Name
  string name;
  // Follower array with a variable size, each element should be a dynamically
  // allocated object of class Follower.
  Follower** followers;
  // The size of follower array.
  int follower_max;
  // Number of followers
  int follower_num;

 public:
  Vtuber(const string& _name);
  ~Vtuber();
  void insert_follower(const string& follower_name, int follower_age);
  void remove_follower(const string& follower_name);
};

```

Specifically, Vtuber's followers member variable is an array of pointers, each pointer pointing to a `Follower` object. The following graph illustrates it.

```{figure} _images/followers.png
```

(1) Implement the constructor for `Vtuber`. Vtuber `name` should be initialized by `_name`, and `follower_max` should be initialized to 2. In addition, you should allocate an array called `followers` using `new`, with an initial size of 2 (the value of `follower_max`). Every element in this array should be a pointer to an object of class `Follower` and initialize all these pointers to `NULL`.
'''

starter-code = '''

Vtuber::Vtuber (const string& _name) {
  
  // Your code here

}

'''

answer = '''

Vtuber::Vtuber(const string& _name) {
  name = _name;
  follower_max = 2;
  follower_num = 0;
  followers = new Follower*[follower_max];
  for (int i = 0; i < follower_max; i++) {
    followers[i] = NULL;
  }
}

'''

append-before = '''
#include <iostream>
#include <string>
using namespace std;

class Follower {
 private:
  string name;
  int age;

 public:
  Follower(const string& _name, int _age) {
    name = _name;
    age = _age;
  }
  string get_name() const { return name; }
  int get_age() const { return age; }
  
};
class Vtuber {
 private:
  string name;
  Follower** followers;
  int follower_max;
  int follower_num;

 public:
  Vtuber(const string& _name);

  // getters for testing
  string get_name() const { return name; }
  int get_follower_max() const { return follower_max; }
  int get_follower_num() const { return follower_num; }
  bool followers_all_null() const {
    for (int i = 0; i < follower_max; i++) {
      if (followers[i] != NULL) return false;
    }
    return true;
  }

};
'''

main-function = '''
int main() {
  string vtuber_name;
  getline(cin, vtuber_name);

  Vtuber v(vtuber_name);

  cout << "Vtuber created: " << v.get_name() << endl;
  cout << "Max followers allowed: " << v.get_follower_max() << endl;
  cout << "Current number of followers: " << v.get_follower_num() << endl;
  cout << "All followers initialized to NULL: "
       << (v.followers_all_null() ? "Yes" : "No") << endl;

  return 0;
}
'''

[[exercises.testcases]]
input = "Q3.P1.T1.in"
output = "Q3.P1.T1.out"

[[exercises.testcases]]
input = "Q3.P1.T2.in"
output = "Q3.P1.T2.out"

[[exercises.testcases]]
input = "Q3.P1.T3.in"
output = "Q3.P1.T3.out"




[[exercises]]
title = "Question 10 in Fall 2022 Midterm Exam"
difficulty = "Challenging"
type = "function programming"
table = false
multipart = true

question = '''

(2) Every Vtuber in `Vtube` can get new followers or lose their current followers. This is implemented by two methods: `insert_follower` and `remove_follower`. Now you are asked to implement these two methods:

a. For insert_follower, a follower name and follower age are given. You need to create a dynamically allocated object of `Follower` and insert it into the followers array (in the first available location), using `new` operator. If the array is full, you should double `follower_max`, allocate a new follower array, and move all the data into this `new` array, and insert the `new` follower. Write the code below.
'''

starter-code = '''
void Vtuber::insert_follower(const string& follower_name, 
                            int follower_age) {

  // Your code here

}
'''

answer = '''
void Vtuber::insert_follower(const string& follower_name, int follower_age) {
  follower_num++;
  for (int i = 0; i < follower_max; i++) {
    if (followers[i] == NULL) {
      followers[i] = new Follower(follower_name, follower_age);
      return;
    }
  }
  Follower** new_followers = new Follower*[2 * follower_max];
  for (int i = 0; i < follower_max; i++) {
    new_followers[i] = followers[i];
    new_followers[i + follower_max] = NULL;
  }
  new_followers[follower_max] = new Follower(follower_name, follower_age);
  delete[] followers;
  followers = new_followers;
  follower_max *= 2;
  return;
}
'''

append-before = '''
#include <iostream>
#include <string>
using namespace std;

class Follower {
 private:
  string name;
  int age;

 public:
  Follower(const string& _name, int _age) {
    name = _name;
    age = _age;
  }
  string get_name() const { return name; }
  int get_age() const { return age; }
};

class Vtuber {
 private:
  string name;
  Follower** followers;
  int follower_max;
  int follower_num;

 public:
  Vtuber(const string& _name);
  void insert_follower(const string& follower_name, int follower_age);

  // Extra helper for testcases
  void print_followers() const {
    cout << "Vtuber: " << name << " has " << follower_num << " followers:" << endl;
    for (int i = 0; i < follower_max; i++) {
      if (followers[i] != NULL) {
        cout << "- " << followers[i]->get_name()
             << " (age " << followers[i]->get_age() << ")" << endl;
      }
    }
  }
};

// Constructor from part (1)
Vtuber::Vtuber(const string& _name) {
  name = _name;
  follower_max = 2;
  follower_num = 0;
  followers = new Follower*[follower_max];
  for (int i = 0; i < follower_max; i++) {
    followers[i] = NULL;
  }
}
  
'''

main-function = '''

int main() {
  string vtuber_name;
  getline(cin, vtuber_name);  // full Vtuber name
  Vtuber v(vtuber_name);

  string command;
  while (cin >> command) {
    if (command == "Insert") {
      int n;
      cin >> n;
      for (int i = 0; i < n; i++) {
        string name;
        int age;
        cin >> name >> age;
        v.insert_follower(name, age);
      }
    } else {
      cerr << "Unknown command: " << command << endl;
      break;
    }
  }

  v.print_followers();
  return 0;
}

'''


[[exercises.testcases]]
input = "Q3.P2a.T1.in"
output = "Q3.P2a.T1.out"

[[exercises.testcases]]
input = "Q3.P2a.T2.in"
output = "Q3.P2a.T2.out"

[[exercises.testcases]]
input = "Q3.P2a.T3.in"
output = "Q3.P2a.T3.out"


[[exercises]]
title = "Question 10 in Fall 2022 Midterm Exam"
difficulty = "Challenging"
type = "function programming"
table = false
multipart = true

question = '''
b. For `remove_follower`, a follower name is given. If there is any follower in the array matching the name, you should remove it and free its memory using `delete`. You can assume the follower names are all unique.
'''

starter-code = '''
void Vtuber::remove_follower(const string& follower_name) {
  
  // Your code here

}
'''

answer = '''
void Vtuber::remove_follower(const string& follower_name) {
  for (int i = 0; i < follower_max; i++) {
    if (followers[i] == NULL)  // 3 marks on skipping NULL members
      continue;
    if (followers[i]->get_name() == follower_name) {  // 1 mark
      follower_num--;                                 // 1 mark
      delete followers[i];                            // 2 mark
      followers[i] = NULL;                            // 1 mark
      break;
    }
  }
  return;
}
'''

append-before = '''
#include <iostream>
#include <string>
using namespace std;

class Follower {
 private:
  string name;
  int age;

 public:
  Follower(const string& _name, int _age) {
    name = _name;
    age = _age;
  }
  string get_name() const { return name; }
  int get_age() const { return age; }
};

class Vtuber {
 private:
  string name;
  Follower** followers;
  int follower_max;
  int follower_num;

 public:
  Vtuber(const string& _name);
  void insert_follower(const string& follower_name, int follower_age);
  void remove_follower(const string& follower_name);

  // Extra helper for testcases
  void print_followers() const {
    cout << "Vtuber: " << name << " has " << follower_num << " followers:" << endl;
    for (int i = 0; i < follower_max; i++) {
      if (followers[i] != NULL) {
        cout << "- " << followers[i]->get_name()
             << " (age " << followers[i]->get_age() << ")" << endl;
      }
    }
  }
};

// Constructor from part (1)
Vtuber::Vtuber(const string& _name) {
  name = _name;
  follower_max = 2;
  follower_num = 0;
  followers = new Follower*[follower_max];
  for (int i = 0; i < follower_max; i++) {
    followers[i] = NULL;
  }
}

// insert_follower from part (2a)
void Vtuber::insert_follower(const string& follower_name, int follower_age) {
  follower_num++;
  for (int i = 0; i < follower_max; i++) {
    if (followers[i] == NULL) {
      followers[i] = new Follower(follower_name, follower_age);
      return;
    }
  }
  Follower** new_followers = new Follower*[2 * follower_max];
  for (int i = 0; i < follower_max; i++) {
    new_followers[i] = followers[i];
    new_followers[i + follower_max] = NULL;
  }
  new_followers[follower_max] = new Follower(follower_name, follower_age);
  delete[] followers;
  followers = new_followers;
  follower_max *= 2;
  return;
}
'''


main-function = '''
int main() {
  string vtuber_name;
  getline(cin, vtuber_name);
  Vtuber v(vtuber_name);

  string command;
  while (cin >> command) {
    if (command == "Insert") {
      int n;
      cin >> n;
      for (int i = 0; i < n; i++) {
        string name;
        int age;
        cin >> name >> age;
        cout << "Inserting follower: " << name << " (age " << age << ")" << endl;
        v.insert_follower(name, age);
      }
    } else if (command == "Remove") {
      int n;
      cin >> n;
      for (int i = 0; i < n; i++) {
        string name;
        cin >> name;
        cout << "Removing follower: " << name << endl;
        v.remove_follower(name);
      }
    } else {
      cout << "Unknown command: " << command << endl;
    }
  }

  v.print_followers();
  return 0;
}
'''

[[exercises.testcases]]
input = "Q3.P2b.T1.in"
output = "Q3.P2b.T1.out"

[[exercises.testcases]]
input = "Q3.P2b.T2.in"
output = "Q3.P2b.T2.out"

[[exercises.testcases]]
input = "Q3.P2b.T3.in"
output = "Q3.P2b.T3.out"

[[exercises]]
title = "Question 10 in Fall 2022 Midterm Exam"
difficulty = "Challenging"
type = "function programming"
table = false
multipart = true

question = '''

(3) Implement the destructor for the `Vtuber` class. You should free all the dynamically allocated objects using `delete`. Remember to be consistent with your previous implementation, as the entire program should not trigger any segmentation fault.

'''

starter-code = '''
Vtuber::~Vtuber() {

  // Your code here
  
}
'''

answer = '''
Vtuber::~Vtuber() {
  for (int i = 0; i < follower_max; i++) {
    delete followers[i];  // delete NULL is safe;
  }
  delete[] followers;
}
'''

append-before = '''
#include <iostream>
#include <string>
using namespace std;

class Follower {
private:
  string name;
  int age;

public:
  static int alive_count;  // counts live objects for testcases

  Follower(const string& _name, int _age) {
      name = _name;
      age = _age;
      alive_count++;
  }

  ~Follower() {
      alive_count--;
  }

  string get_name() const { return name; }
  int get_age() const { return age; }
};

int Follower::alive_count = 0;

class Vtuber {
 private:
  string name;
  Follower** followers;
  int follower_max;
  int follower_num;

 public:
  Vtuber(const string& _name);
  ~Vtuber();
  void insert_follower(const string& follower_name, int follower_age);
  void remove_follower(const string& follower_name);

  // Extra helper for testcases
  void print_followers() const {
    cout << "Vtuber: " << name << " has " << follower_num << " followers:" << endl;
    for (int i = 0; i < follower_max; i++) {
      if (followers[i] != NULL) {
        cout << "- " << followers[i]->get_name()
             << " (age " << followers[i]->get_age() << ")" << endl;
      }
    }
  }
};

// Constructor from part (1)
Vtuber::Vtuber(const string& _name) {
  name = _name;
  follower_max = 2;
  follower_num = 0;
  followers = new Follower*[follower_max];
  for (int i = 0; i < follower_max; i++) {
    followers[i] = NULL;
  }
}

// insert_follower from part (2a)
void Vtuber::insert_follower(const string& follower_name, int follower_age) {
  follower_num++;
  for (int i = 0; i < follower_max; i++) {
    if (followers[i] == NULL) {
      followers[i] = new Follower(follower_name, follower_age);
      return;
    }
  }
  Follower** new_followers = new Follower*[2 * follower_max];
  for (int i = 0; i < follower_max; i++) {
    new_followers[i] = followers[i];
    new_followers[i + follower_max] = NULL;
  }
  new_followers[follower_max] = new Follower(follower_name, follower_age);
  delete[] followers;
  followers = new_followers;
  follower_max *= 2;
  return;
}

// remove_follower from part 2b
void Vtuber::remove_follower(const string& follower_name) {
  for (int i = 0; i < follower_max; i++) {
    if (followers[i] == NULL)  // 3 marks on skipping NULL members
      continue;
    if (followers[i]->get_name() == follower_name) {
      follower_num--;
      delete followers[i];
      followers[i] = NULL;
      break;
    }
  }
  return;
}
'''

main-function = '''

int main() {
  string vtuber_name;
  getline(cin, vtuber_name);
  Vtuber* v = new Vtuber(vtuber_name);

  string command;
  while (cin >> command) {
    if (command == "Insert") {
      int n;
      cin >> n;
      for (int i = 0; i < n; i++) {
        string name;
        int age;
        cin >> name >> age;
        cout << "Inserting follower: " << name << " (age " << age << ")" << endl;
        v->insert_follower(name, age);
      }
    } else if (command == "Remove") {
      int n;
      cin >> n;
      for (int i = 0; i < n; i++) {
        string name;
        cin >> name;
        cout << "Removing follower: " << name << endl;
        v->remove_follower(name);
      }
    } else {
      cout << "Unknown command: " << command << endl;
    }
  }

  // Print before destructor
  v->print_followers();
  cout << "Followers alive before delete: " << Follower::alive_count << endl;

  delete v;  // destructor called here

  // After destructor, alive_count should be 0
  cout << "Followers alive after delete: " << Follower::alive_count << endl;

}

'''

[[exercises.testcases]]
input = "Q3.P3.T1.in"
output = "Q3.P3.T1.out"

[[exercises.testcases]]
input = "Q3.P3.T2.in"
output = "Q3.P3.T2.out"

[[exercises.testcases]]
input = "Q3.P3.T3.in"
output = "Q3.P3.T3.out"

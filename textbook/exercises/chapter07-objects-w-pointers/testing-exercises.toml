[[exercises]]
title = "Question 5 in Fall 2019 Midterm Exam"
difficulty = "Easy"
table = false
type = "explaination"
multipart= true

question = """

Consider a (non-member) function called `doIt`, which takes a single object of type `DayOfYear` and returns a single object also of type `DayOfYear`. You may assume that the class `DayOfYear` is correctly implemented and that `DayOfYear.h` is included. Which of the
following implementations of this function is problem-free? 

(1)
```{code-block} cpp
DayOfYear doIt(DayOfYear& arg) {
  DayOfYear temp;
  temp = arg;
  return (arg);
}
```
"""

answer = """
Has no problem. We return `arg` by value and we create a copy of `arg` using copy constructor.
"""



[[exercises]]
title = "Question 5 in Fall 2019 Midterm Exam"
difficulty = "Easy"
table = false
type = "explaination"
multipart= true

question = """
(2)
```{code-block} cpp
DayOfYear doIt(DayOfYear& arg) {
  DayOfYear temp;
  temp = arg;
  return (temp);
}
```
"""

answer = """
Has no problem. We return `temp` by value and we create a copy of `temp` using copy constructor.
"""

[[exercises]]
title = "Question 5 in Fall 2019 Midterm Exam"
difficulty = "Easy"
table = false
type = "explaination"
multipart= true

question = """
(3)
```{code-block} cpp
DayOfYear& doIt(DayOfYear& arg) {
  DayOfYear temp;
  temp = arg;
  return (*this);
}
```
"""

answer = """
Has a problem, because in the question it says `doIt` is a non-member function. Since this is a pointer to an 
object on which the member function is invoked, it can only be accessed in a member function. In short, we 
cannot access `this` in `doIt` function.
"""

[[exercises]]
title = "Question 5 in Fall 2019 Midterm Exam"
difficulty = "Easy"
table = false
type = "explaination"
multipart= true

question = """
(4)
```{code-block} cpp
DayOfYear& doIt(DayOfYear& arg) {
  DayOfYear temp;
  temp = arg;
  return (temp);
}
```
"""

answer = """
Has a problem, but it is quite tricky. `temp` is a local only to the function `doIt` since it was defined only
inside the function. `temp` will go out of scope or disappear from the memory the moment we return from `doIt`
function. If we return `temp` by reference, and `temp` actually is non-existing after the function call, the 
behavior is undefined if we try accessing whatever `doIt` returns.
"""


[[exercises]]
title = "Modified Version of Question 5 in Fall 2019 Final Exam"
difficulty = "Intermediate"
type = "tracing"
table = false
multipart = true

question = """
Consider the following class definition and implementation.

```{code-block} cpp
#include <iostream>
using namespace std;

class Duo {
 private:
  int* p;
  int* q;

 public:
  Duo(int a, int b) {
    p = new int;
    *p = a;
    q = new int;
    *q = b;
  }
  int get_a() { return *p; }
  int get_b() { return *q; }
  void set_a(int a) { *p = a; }
  void set_b(int b) { *q = b; }
  Duo funnyMultiply(Duo& rhs) {
    Duo temp(0, 0);
    *(temp.p) = (*p) * *(rhs.p);
    *(temp.q) = (*q) * *(rhs.q);
    *(rhs.p) = *(rhs.p) - 1;
    *(rhs.q) = *(rhs.q) - 1;
    return (temp);
  }
  Duo print() {
    cout << *p << " " << *q << endl;
    return (*this);
  }
};
```

The following `main` program uses class `Duo`.

```{code-block} cpp
int main() {
  Duo X(3, 5);
  Duo Y(8, 9);
  Duo Z(2, 4);
  Z = X.funnyMultiply(Y);
  Z.print();  // Statement 1
  Z.set_a(1);
  Z.set_b(2);
  Z.print();  // Statement 2
  X.print();  // Statement 3
  Y.print();  // Statement 4
  Duo W(6, 12);
  Duo V(2, 3);
  W.print().funnyMultiply(V).print();  // Statement 5
  W.print();                           // Statement 6
  // Point A
  cout << "Program is done" << endl;
  return (0);
}
```

(1) Write the output produced by each of the labeled statement (Statement 1 to
Statement 6) in main. Write your answer in the table below.

a. Statement 1:
"""

answer = "24 45"

[[exercises]]
title = "Modified Version of Question 5 in Fall 2019 Final Exam"
difficulty = "Intermediate"
type = "tracing"
table = false
multipart = true

question = """
b. Statement 2:
"""
answer = """
1 2
"""

[[exercises]]
title = "Modified Version of Question 5 in Fall 2019 Final Exam"
difficulty = "Intermediate"
type = "tracing"
table = false
multipart = true

question = """
c. Statement 3:
"""
answer = """
3 5
"""

[[exercises]]
title = "Modified Version of Question 5 in Fall 2019 Final Exam"
difficulty = "Intermediate"
type = "tracing"
table = false
multipart = true

question = """
d. Statement 4:
"""
answer = """
7 8
"""

[[exercises]]
title = "Modified Version of Question 5 in Fall 2019 Final Exam"
difficulty = "Intermediate"
type = "tracing"
table = false
multipart = true

question = """
e. Statement 5:
"""
answer = """
6 12 
12 36
"""

[[exercises]]
title = "Modified Version of Question 5 in Fall 2019 Final Exam"
difficulty = "Intermediate"
type = "tracing"
table = false
multipart = true

question = """
f. Statement 6:
"""
answer = """
6 12 
"""

[[exercises]]
title = "Modified Version of Question 5 in Fall 2019 Final Exam"
difficulty = "Intermediate"
type = "explaination"
table = false
multipart = true

question = """
(2) How many integers exist in memory in the form of a memory leak when execution
reaches Point A in the main function above? Write your answer in the box below.
"""
answer = """
Z initially had p and q pointing to two integers, and we lost access to them when we pointed to p and q from the object returned by value in `Z = X.funnyMultiply(Y);`.

Another two integers were lost in `W.print().funnyMultiply(V).print();` after returning from `funnyMultiply` function. 

Total, we have 4 integers in the memory exist in the form of a memory leak. 
"""






[[exercises]]
title = "Question 10 in Fall 2021 Final Exam"
difficulty = "Easy"
type = "explaination"
table = false
multipart = true

question = '''

Consider the following binary tree. The keys of the nodes are shown below inside the nodes. 

```{figure} _images/tree-traversal.png
```

(1) What is the *preorder* traversal of the tree?

'''

answer = '''
1 2 3 4 5 6 7

**(NLR)** Nodes are visited recursively printing root node, left subtree then right subtree. This means when you print the left subtree, print it also by starting with the root, left node, then right node. 

'''

[[exercises]]
title = "Question 10 in Fall 2021 Final Exam"
difficulty = "Easy"
type = "explaination"
table = false
multipart = true

question = '''
(2) What is the *inorder* traversal of the tree? 
'''

answer = '''
3 2 4 1 5 7 6

**(LNR)** Nodes are visited recursively printing left subtree, root node, then right subtree. This means when you print the left subtree, print it also by starting with the left node, root node, then right node. 
'''


[[exercises]]
title = "Question 10 in Fall 2021 Final Exam"
difficulty = "Easy"
type = "explaination"
table = false
multipart = true

question = '''
(3) What is the *postorder* traversal of the tree? 
'''

answer = '''
3 4 2 7 6 5 1

**(LRN)** Nodes are visited recursively printing left subtree, right subtree, then root node. This means when you print the left subtree, print it also by starting with the left node, right node, then root node. 
'''


[[exercises]]
title = "Question 9 in Fall 2022 Final Exam"
difficulty = "Intermediate"
type = "function programming"
table = false
multipart = false

question = '''
A binary tree is symmetric if the root node's left subtree is exactly a mirror reflection of the right subtree. For example, the tree on the left is symmetric, but the tree on the right is not.

```{figure} _images/symmetric-tree.png
```

```{figure} _images/not-symmetric-tree.png
```

Now, you are asked to complete the function `is_symmetric`. It should return `true` if and only if the root is a symmetric tree. You should fill out the **recursive** helper function
`is_symmetric_helper` to make `is_symmetric` work as expected. Hint: you should write less than 15 lines of code.

**NOTE:** please use `nullptr` instead of `NULL`
'''

starter-code = '''

/* Definition of the tree node */
class TreeNode {
 public:
  int data;
  TreeNode* left;
  TreeNode* right;
};

/* Recursive helper */
bool is_symmetric_helper(TreeNode* left, TreeNode* right){
  
  // TO DO: Complete the helper function "is_symmetric_helper".

}

bool is_symmetric(TreeNode* root) {
  if (root == nullptr) {
    return true;
  }
  return is_symmetric_helper(root->left, root->right);
}
'''

answer = '''

bool is_symmetric_helper(TreeNode* left, TreeNode* right) {
  if (left != nullptr && right != nullptr) {
    if (left->data == right->data) {
      return is_symmetric_helper(left->left, right->right) &&
             is_symmetric_helper(right->left, left->right);
    } else {
      return false;
    }
  } else {
    if (left == nullptr && right == nullptr) {
      return true;
    } else {
      return false;
    }
  }
}
'''

main-function = '''

#include <iostream>
#include <queue>
using namespace std;


/* Helper function to allocate a node */

TreeNode* makeNode(int val) {
  TreeNode* node = new TreeNode;
  node->data = val;
  node->left = nullptr;
  node->right = nullptr;
  return node;
}

/* Helper function to build tree */
TreeNode* buildTree(int n) {
  if (n == 0) return nullptr;
  int val;
  cin >> val;
  if (val == -1) return nullptr;

  TreeNode* root = makeNode(val);
  queue<TreeNode*> q;
  q.push(root);

  int count = 1;
  while (!q.empty() && count < n) {
    TreeNode* node = q.front();
    q.pop();

    int leftVal, rightVal;

    if (count < n) {
      cin >> leftVal;
      count++;
      if (leftVal != -1) {
        node->left = makeNode(leftVal);
        q.push(node->left);
      }
    }

    if (count < n) {
      cin >> rightVal;
      count++;
      if (rightVal != -1) {
        node->right = makeNode(rightVal);
        q.push(node->right);
      }
    }
  }

  return root;
}

int main() {
  int n;
  cin >> n;  // number of nodes in level-order
  TreeNode* root = buildTree(n);

  if (is_symmetric(root))
    cout << "tree IS symmetric" << endl;
  else
    cout << "tree IS NOT symmetric" << endl;

  return 0;
}
'''

[[exercises.testcases]]
input = "Q2.T1.in"
output = "Q2.T1.out"

[[exercises.testcases]]
input = "Q2.T2.in"
output = "Q2.T2.out"

[[exercises.testcases]]
input = "Q2.T3.in"
output = "Q2.T3.out"

[[exercises.testcases]]
input = "Q2.T4.in"
output = "Q2.T4.out"

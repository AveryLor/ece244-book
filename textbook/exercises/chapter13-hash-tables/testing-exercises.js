let parsedObject; 
  parsedObject = {
  "exercises": [
    {
      "title": "Question 10 in Fall 2022 Final Exam",
      "difficulty": "Challenging",
      "type": "function programming",
      "table": false,
      "multipart": true,
      "question": "Thanks to your previous implementation of the VTuber, it became an instant modern classic. With great popularity comes greater responsibility. Now there are more than 300,000 VTubers streaming on the MeTube, and your engineering manager asks you to implement a data structure that allows users to quickly lookup whether a specific Vtuber is currently live-streaming. \n\nA native solution would be using an array of 300,000 entries, with each entry holding a boolean variable indicating whether the corresponding Vtuber is live-streaming or not. However, there are two major problems: \n\n1. Users can only query the database with Vtubers' names, not some internal ids.\n2. Only ~20% of total Vtubers are streaming at any given time, so most array enteries are inactive. However, you'd like to maintain a lookup time that is approximately $O(n)$.\n\nNow, you suddenly recall that in ECE 244 you learned the hash table, which resolves collisions with chaining. The hash table would suit your needs perfectly. Even better, you can use an existing linked list implementation written by your new colleague.\n\nThe following is the class declaration of the linked list. Assume that it works correctly and encapsulates all the operations your hash table may need. Read it carefully, as you will need it to build your VTubers hash table later. **Remember, it will not allocate any list node automatically, and only the destructor will deallocate list node memory.**\n\n```{code-block} cpp\n#include <iostream>\nusing namespace std;\n\nclass ListNode {\n public:\n  ListNode(const string& name_) {\n    name = name_;\n    next = NULL;\n  };\n  string name;\n  ListNode* next;\n};\n\nclass LinkedList {\n private:\n  ListNode* head;\n\n public:\n  // Default constructor: initialize the head to NULL.\n  LinkedList();\n\n  // Return true if and only if the list is empty,\n  bool is_empty();\n\n  // Insert the given node to the head of the list.\n  // Time complexity: 0(1)\n  void insert(ListNode* node);\n\n  // Traversing from the head. Remove the first node found with the given\n  // name from the list. The removed node is NOT deallocated.\n  // Returns this node (or NULL if the name is not found).\n  // Time complexity: 0(n)\n  ListNode* remove(const string& name);\n\n  // Return true if there exists at least one node with the given name.\n  // Time complexity: 0(n)\n  bool find(const string& name);\n\n  // Remove the current head node from the linked list,\n  // and return it.\n  // Move the head one node forward.\n  // Time complexity: 0(1)\n  ListNode* pop_head();\n\n  // Destructor: Properly deallocate all the nodes.\n  ~LinkedList();\n};\n```\n\nAlso, you are given a string hash function, which uses a secret algorithm to turn the given string into a non-negative integer value. You can safely assume that given the same string inputs, the output value is always the same. However, two different strings may be turned into the same number.\n\n```{code-block} cpp\nint string_hash(const string& name);\n```\n\nAnd finally, here is how the hash table is declared. It stores all the names of active VTubers at a given time, **using the name as a unique key**. The hash table **solves collisions by chaining** using the linked list.\n\n```{code-block} cpp\n#define INIT_CAPACITY 32\nclass HashTable {\n private:\n  // Array of Linked List: resolving collisions by chaining\n  LinkedList** table;\n  // The length of the table array,\n  int table_slot_size;\n  // Keep track of how many elements (names) are in the hash table\n  int num_elements;\n  int get_hash_index(const string& name) {\n    return string_hash(name) % table_slot_size;\n  }\n\n public:\n  // Constructors and destructors.\n  HashTable();\n  ~HashTable();\n  // Hash table method,\n  bool exist(const string& name);\n  bool insert(const string& name);\n  bool remove(const string& name);\n  bool change_name(const string& old_name, const string& new_name);\n};\n```\n\nEssentially, the hash table should be similar to what has been discussed during the lecture. The\nfollowing diagram should help you visualize what this hash table looks like:\n\n\n\n```{figure} _images/hashtable.png\n```\n\nWhen a VTuber goes online for streaming, `insert()` should be called to bring the name into the\nhash table. When the VTuber goes offline, `remove()` method should be called to remove the\nname from the hash table. The constructor and `exist()` methods are already implemented as\nshown below. They should help you clarify how the hash table works.\n\n\n```{code-block} cpp\nHashTable::HashTable() {\n  table = new LinkedList*[INIT_CAPACITY];\n  table_slot_size = INIT_CAPACITY;\n  num_elements = 0;\n  for (int i = 0; i < table_slot_size; ++i) {\n    table[i] = NULL;\n  }\n}\nbool HashTable::exist(const string& name) {\n  int idx = this->get_hash_index(name);\n  if (table[idx] == NULL) {\n    return false;\n  }\n  return table[idx]->find(name);\n}\n```\n\n(1) Implement the `insert()` method of the hash table. The insert should fulfill the following requirements:\n\na. You should maintain the unique name property. If the name already exists in the hash table, you should return false. Otherwise, allocate a list node for the string and insert it into the correct list, and return true.\n\nb. To address the collision, your hashtable should dynamically grow at run time. Specifically, when you try to insert a new name but the value of `num_elements` will\nbecome equal to or larger than `table_slot_size/2`, you should double\n`table_slot_size` and allocate a new table with the updated size. Then, you should\nmove all the existing names from the old table to the newly allocated table, and\ndeallocate the old table. Notice that the hash index is directly related to the `table_slot_size`, so the hash index of the same name can be changed when moving from one table to another.\n\nc. You can add additional member functions if you need to.\nd. Your code should not trigger any segmentation fault, and it should not leak memory.\nYou can define helper functions if you find them useful. You can make helpers as member functions if you think that would be necessary.\n\n",
      "starter-code": "// Implement bool HashTable::insert(const string& name), and define\n// any helper functions here.\n\nImplement bool HashTable::insert(const string& name){\n\n\n}\n",
      "answer": "\nbool HashTable::insert(const string& name) {\n  if (this->exist(name)) {\n    return false;  // found!\n}\n\n  // not found!\n  if (num_elements + 1 >= table_slot_size / 2) {\n    table_slot_size = table_slot_size * 2;\n    LinkedList** newTable = new LinkedList*[table_slot_size];\n    for (int i = 0; i < table_slot_size; i++) {\n      newTable[i] = nullptr;\n    }\n\n    for (int i = 0; i < table_slot_size / 2; ++i) {\n      if (table[i] != NULL) {\n        ListNode* n = table[i]->pop_head();\n        while (n != NULL) {\n          int idx = get_hash_index(n->name);\n          if (newTable[idx] == NULL) {\n            newTable[idx] = new LinkedList;  // msh\n          }\n          newTable[idx]->insert(n);\n          n = table[i]->pop_head();\n        }\n        delete table[i];\n      }\n    }\n    delete[] table;\n    table = newTable;\n  }\n\n  int idx = this->get_hash_index(name);\n\n  if (table[idx] == NULL) {\n    table[idx] = new LinkedList;  // msh\n  }\n  ListNode* n = new ListNode(name);\n  table[idx]->insert(n);\n  num_elements++;\n  return true;\n}\n\n"
    },
    {
      "title": "Question 10 in Fall 2022 Final Exam",
      "difficulty": "Challenging",
      "type": "function programming",
      "table": false,
      "multipart": true,
      "question": "\n(2) Implement the `remove` method. Return true if the given name exists and is successfully removed, otherwise, \nreturn false. Your code should not trigger any segmentation fault, and it should not leak memory.\n\n",
      "starter-code": "bool HashTable::remove(const string& name) {\n\n  // Your code here\n\n}  \n",
      "answer": "\nbool HashTable::remove(const string& name) {\n  if (this->exist(name)) {\n    int idx = this->get_hash_index(name);\n    ListNode* removeNode = table[idx]->remove(name);\n    delete removeNode;\n    num_elements--;\n    return true;\n  }\n  // not found!\n  return false;\n}    \n\n"
    },
    {
      "title": "Question 10 in Fall 2022 Final Exam",
      "difficulty": "Challenging",
      "type": "function programming",
      "table": false,
      "multipart": true,
      "question": "\n(3) Implement the `change_name` method. It removes the `old_name` and inserts the\n`new_name`. Return true if successful. Otherwise, it returns false either when the `old_name`\ndoesnâ€™t exist, or the `new_name` is the same as any existing name. Your code should not trigger\nany segmentation fault, and it should not leak memory. Hint: you can use the function you\nimplemented in the previous questions.\n",
      "starter-code": "bool HashTable::change_name(const string& old_name, const string& new_name) {\n\n  // Your code here\n\n}  \n",
      "answer": "bool HashTable::change_name(const string& old_name, const string& new_name) {\n  if (this->exist(old_name) && !this->exist(new_name)) {\n    // change name!\n    this->remove(old_name);\n    this->insert(new_name);\n    return true;\n  } else if (this->exist(old_name) && this->exist(new_name)) {\n    // don't change name\n    return false;\n  } else if (!this->exist(old_name)) {\n    // din't find\n    return false;\n  } else {\n    // not needed!\n    return false;\n  }\n}\n"
    },
    {
      "title": "Question 10 in Fall 2022 Final Exam",
      "difficulty": "Challenging",
      "type": "function programming",
      "table": false,
      "multipart": true,
      "question": "\n(4) Implement the destructor of `HashTable`. It should deallocate the table array and all\nthe lists. Your code should not trigger any segmentation fault, and it should not leak memory.\n",
      "starter-code": "HashTable::~HashTable() {\n\n  // Your code here\n\n}  \n",
      "answer": "HashTable::~HashTable() {\n  for (int i = 0; i < table_slot_size; i++) {\n    delete table[i];\n  }\n  delete[] table;\n}\n"
    }
  ]
};